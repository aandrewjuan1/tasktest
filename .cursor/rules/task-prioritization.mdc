---
description: TaskLyst Task Prioritization Module - LLM-powered intelligent task priority assignment with reasoning (Core logic focus)
globs:
  - app/Services/TaskPrioritizationService.php
  - app/Services/Schemas/TaskPrioritizationSchema.php
  - app/Models/Task.php
alwaysApply: false
---

# TaskLyst - Task Prioritization Module

## Module Overview

This module implements **LLM-powered intelligent task prioritization**. The AI analyzes user tasks considering urgency, importance, deadlines, and dependencies, then assigns optimal priority levels with clear reasoning.

### Core Capability

**Reactive Prioritization**: Analyze current task list and assign priority levels (1-10) with human-readable explanations.

### Dual-Output Architecture

The LLM produces TWO outputs in a single structured response:

1. **User Message** (`user_message`): Natural language explanation for the frontend to display
2. **Backend Data** (`task_updates`): Structured JSON for database updates via Eloquent

## System Flow

```
User Action
    ↓
Frontend Component
    ↓
TaskPrioritizationService (Core Logic)
    ↓
Prism → Hermes 3 LLM
    ↓
Structured JSON Response
    ↓
┌───────────────┴──────────────┐
↓                              ↓
Return to Frontend        Backend Receives Data
(user_message)            (task_updates array)
    ↓                              ↓
Display to User           Eloquent Updates Database
```

## File Structure

```
app/Services/
├── TaskPrioritizationService.php        # Core LLM integration logic
└── Schemas/
    └── TaskPrioritizationSchema.php     # Structured output schema

app/Models/
└── Task.php                             # Eloquent model with priority field
```

---

## Core Component: TaskPrioritizationService

**File**: `app/Services/TaskPrioritizationService.php`

**Purpose**: Core business logic for LLM-powered task prioritization

### Public API

**Method Signature:**
- `analyzeTasks(array $tasks, array $userContext): ?array`

**Input Parameters:**
- `$tasks`: Array of task objects with keys: `id`, `title`, `description`, `priority`, `due_date`, `estimated_duration`, `status`
- `$userContext`: Array with keys: `user_id`, `available_hours_per_day`, `current_date`, `working_days`

**Output:**
- Array with structured response (see schema below)
- `null` on failure

### Implementation Requirements

- Create `analyzeTasks()` method accepting tasks array and user context
- Return structured array with user message and task updates, or null on failure
- Use Prism with Ollama provider and Hermes 3 model
- Apply system prompt defining AI's role and constraints
- Build user prompt with task list and context data
- Attach TaskPrioritizationSchema for structured output validation
- Set timeout to 120+ seconds for LLM processing
- Return structured response or null on exception
- Log errors with user_id context for debugging

**System Prompt Requirements:**
- Define system prompt instructing LLM to:
  - Analyze tasks considering urgency, importance, deadlines, dependencies
  - Assign priority scores (1-10 scale)
  - Provide reasoning for each assignment
  - Output both user-facing message and structured task updates

**User Prompt Requirements:**
- Format user prompt with:
  - Current date and available working hours
  - Complete task list with all relevant attributes
  - User's working days schedule
  - Request for priority analysis

### Key Patterns

- **Timeout**: 120+ seconds for Ollama processing
- **Error Handling**: Catch `PrismException`, log with context, return `null` on failure
- **No Exceptions**: Service never throws exceptions to frontend
- **Stateless**: Pure function, no side effects

---

## Core Component: TaskPrioritizationSchema

**File**: `app/Services/Schemas/TaskPrioritizationSchema.php`

**Purpose**: Define structured output format for LLM responses

### Schema Definition

**Root Schema Structure:**
- Root type: `ObjectSchema` (Prism requirement)
- Primary fields:
  - `user_message` (StringSchema): Natural language explanation for display
  - `task_updates` (ArraySchema): Array of task update objects
  - `reasoning` (StringSchema, optional): Detailed prioritization logic explanation

**Task Update Object Schema:**
- `task_id` (IntegerSchema, required): Database task ID
- `priority` (IntegerSchema, required): New priority level (1-10)
- `reasoning` (StringSchema, optional): Explanation for this specific task's priority

### Expected LLM Output Structure

```json
{
  "user_message": "I've analyzed your tasks and reprioritized them...",
  "task_updates": [
    {
      "task_id": 123,
      "priority": 2,
      "reasoning": "High urgency due to tomorrow's deadline"
    }
  ],
  "reasoning": "Overall prioritization considered deadlines and dependencies..."
}
```

### Schema Requirements

- Root MUST be `ObjectSchema` (Prism requirement)
- Use descriptive names and descriptions for AI clarity
- Mark critical fields in `requiredFields`
- Use appropriate schema types for validation

---

## Data Model: Task

**File**: `app/Models/Task.php`

**Purpose**: Eloquent model for tasks with priority management

### Database Schema

**Table**: `tasks`

**Fields:**
- `id` (primary key)
- `user_id` (foreign key → users.id, CASCADE)
- `title` (varchar, required)
- `description` (text, nullable)
- `priority` (int, default 5, range 1-10)
- `due_date` (timestamp, nullable)
- `estimated_duration` (int minutes, nullable)
- `status` (enum: pending|in_progress|completed, default pending)
- `created_at`, `updated_at` (timestamps)

**Indexes:**
- `(user_id, priority)`
- `(user_id, status)`
- `(user_id, due_date)`

### Model Definition

**Fillable Fields:**
- `title`, `description`, `priority`, `due_date`, `estimated_duration`, `status`

**Relationships:**
- `belongsTo(User::class)` - Each task belongs to one user

**Query Scopes:**
- `pending()` - Filter by pending status
- `byPriority()` - Order by priority ascending
- `overdue()` - Filter tasks past due_date

**Casts:**
- `due_date` → `datetime`
- `priority` → `integer`
- `estimated_duration` → `integer`

### Priority Scale Reference

- **1-2**: Critical urgency (do today/tomorrow)
- **3-5**: Important work (this week)
- **6-7**: Moderate priority (next week)
- **8-10**: Low priority (when available)

---

## Integration with Frontend

### Service Call Pattern

**Frontend Responsibilities:**
1. Fetch incomplete tasks for current user with relevant fields
2. Build user context array with scheduling parameters:
   - `user_id`
   - `available_hours_per_day`
   - `current_date`
   - `working_days` (array)
3. Invoke service: `TaskPrioritizationService->analyzeTasks($tasks, $userContext)`
4. Handle null response with user-friendly error message

### Processing the Response

**On Successful Response:**

**Extract Dual Outputs:**
1. `user_message` - Display to user in UI
2. `reasoning` - Show detailed explanation (optional)
3. `task_updates` - Process for database persistence

**Response Structure:**
- Check for `user_message` key (string)
- Check for `task_updates` key (array of objects)
- Validate each task update has `task_id` and `priority`

### Database Update Pattern

**Update Workflow:**
1. Use database transaction for atomic updates
2. Loop through `task_updates` array
3. Update tasks via Eloquent with `user_id` scoping for security
4. Validate task ownership before update
5. Commit transaction only if all updates succeed
6. Rollback on any failure

**Security Requirements:**
- Always scope task queries by authenticated `user_id`
- Validate each `task_id` belongs to current user
- Never trust LLM output without verification

---

## Security Considerations

### User Data Isolation

**Critical Rule: Always scope by user_id**
- Prevent cross-user data access
- All task queries must include `where('user_id', auth()->id())`
- Validate task ownership before any update operation

### Input Validation

**Pre-Service Validation:**
- Validate task ownership: Ensure task IDs belong to authenticated user
- Verify required fields are present in task data
- Check user context contains valid user_id

**Post-Service Validation:**
- Sanitize LLM output: Check `task_id` exists in database before update
- Bounds checking: Ensure priority is within 1-10 range
- Type validation: Verify `task_id` and `priority` are integers

### Error Handling

**Service Layer:**
- Never expose raw errors to frontend
- Service returns `null` on failure
- Use Laravel's logging for debugging: `Log::error('Prioritization failed', ['user_id' => $userId, 'error' => $e->getMessage()])`

**Frontend Layer:**
- Display generic error messages to users
- Log detailed errors for developers
- Provide retry mechanism for transient failures

---

## Testing Strategy

### Service Unit Tests

**Required Test Cases:**
- Verify `analyzeTasks()` returns array with required keys: `user_message`, `task_updates`
- Ensure `task_updates` is array of objects
- Validate service returns `null` on LLM failure
- Check each task update contains `task_id` and `priority` (integers)
- Verify priority values are within 1-10 range
- Test timeout handling (mock slow LLM response)
- Test exception handling (mock Prism exception)

**Test Mocking:**
- Mock Prism facade for predictable responses
- Mock Ollama provider to avoid external dependencies
- Use factories for task and user data generation

### Model Tests

**Required Test Cases:**
- Verify task priority can be updated via Eloquent
- Test `byPriority()` scope orders correctly (ascending)
- Validate `pending()` and `overdue()` scopes filter appropriately
- Ensure user relationship works correctly
- Test mass assignment protection
- Verify casts work for date and integer fields

**Database Tests:**
- Use database transactions for test isolation
- Test foreign key constraints (cascade delete)
- Verify indexes exist on expected columns

---

## Performance Optimization

### Database Indexing

**Required Indexes:**
- Add composite indexes on:
  - `(user_id, priority)` - For priority-based queries
  - `(user_id, status)` - For status filtering
  - `(user_id, due_date)` - For deadline queries
- Create indexes via migration for query performance

**Index Creation:**
- Use database migrations to add indexes
- Monitor query performance with Laravel debugbar
- Analyze slow query logs

### Query Optimization

**Best Practices:**
- Eager load relationships when accessing related data: `Task::with('user')`
- Select only required columns to reduce payload: `select(['id', 'title', 'priority'])`
- Use query builder efficiently for filtered datasets
- Avoid N+1 queries with proper eager loading
- Paginate large result sets

### Caching User Context

**Cache Strategy:**
- Cache user context data (available hours, working days) with reasonable TTL (e.g., 1 hour)
- Use user-scoped cache keys: `"user_context_{$userId}"`
- Invalidate cache on user preference updates
- Use Laravel's cache facade for consistency

**Cache Implementation:**
- Store frequently accessed user settings
- Set appropriate expiration times
- Use cache tags for easy invalidation

---

## Environment Configuration

### Required Environment Variables

```env
PRISM_PROVIDER=ollama
OLLAMA_BASE_URL=http://localhost:11434
OLLAMA_MODEL=hermes3:latest
```

### Prism Configuration

**File**: `config/prism.php`

**Configuration Requirements:**
- Configure Prism provider settings for Ollama
- Set base URL pointing to Ollama instance
- Define default model (hermes3 or equivalent)
- Configure timeout settings (120+ seconds)
- Set connection options for reliability

---

## Usage Example Flow

### Complete Integration Example

**Step-by-Step Workflow:**

1. **Frontend collects pending tasks** for authenticated user
   - Query tasks with `where('user_id', auth()->id())->where('status', 'pending')`
   - Include fields: id, title, description, priority, due_date, estimated_duration

2. **Prepare user context** with scheduling parameters
   - `user_id`: Authenticated user's ID
   - `available_hours_per_day`: User's setting (e.g., 8)
   - `current_date`: Carbon::now()
   - `working_days`: Array of working days (e.g., ['Monday', 'Tuesday', ...])

3. **Call TaskPrioritizationService->analyzeTasks($tasks, $userContext)**
   - Service invokes Prism with Ollama
   - LLM analyzes and returns structured response
   - Service returns array or null

4. **Handle null response** (service failure)
   - Display user-friendly error: "Unable to analyze tasks right now. Please try again."
   - Log error details for debugging
   - Provide retry button

5. **Extract dual outputs** on success
   - `user_message`: Extract for UI display
   - `task_updates`: Extract for database persistence
   - `reasoning`: Optional detailed explanation

6. **Wrap database updates in transaction** for atomicity
   - Use `DB::transaction(function() { ... })`
   - Ensures all-or-nothing updates

7. **Update each task's priority** via Eloquent
   - Loop through `task_updates` array
   - Scope by `user_id` for security: `Task::where('user_id', auth()->id())->where('id', $taskUpdate['task_id'])->update(['priority' => $taskUpdate['priority']])`
   - Validate task exists and belongs to user

8. **Display user_message and reasoning** to user in frontend
   - Show success notification
   - Display prioritization explanation
   - Refresh task list with new priorities

---

## Critical Reminders

1. **Dual Output Architecture**: Service returns both user message and backend data in single response
2. **Stateless Service**: No side effects, pure business logic - service doesn't touch database
3. **Error Handling**: Service returns `null` on failure, never throws exceptions to frontend
4. **User Scoping**: Frontend MUST scope all queries by `user_id` for security
5. **Transaction Safety**: Frontend wraps updates in `DB::transaction()` for atomicity
6. **Schema Validation**: Prism enforces structure via ObjectSchema before returning to service
7. **Timeout Configuration**: 120+ seconds for Ollama processing to prevent premature failures
8. **Priority Scale**: 1 = highest urgency, 10 = lowest urgency (inverse scale)

---

## Separation of Concerns

- **This Module** (Backend): Core business logic (service + schema + model)
- **UI/UX Rules** (Frontend): Frontend implementation (component, views, user interaction)
- **Integration Point**: Service returns structured data, frontend displays and persists it
- **Laravel Boosts**: Handles framework conventions, code style, dependency injection patterns